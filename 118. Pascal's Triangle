Approach: Row Generation (generateRow): Purpose: To generate a specific row of Pascal's Triangle. Algorithm: Start with the first element of the row, which is always 1. Use the combinatorial formula to compute each subsequent element in the row. current_element = previous_element Ã— ( ğ‘Ÿ ğ‘œ ğ‘¤ âˆ’ ğ‘ ğ‘œ ğ‘™ ) ğ‘ ğ‘œ ğ‘™ current_element= col previous_elementÃ—(rowâˆ’col) â€‹ where row is the index of the row being generated, and col is the column index within that row. Append each computed value to the ansRow vector. Complexity: Generating a single row takes ğ‘‚ ( row ) O(row) time. Triangle Generation (generate): Purpose: To generate Pascal's Triangle up to a given number of rows (numRows). Algorithm: Initialize an empty vector ans to store the rows of Pascal's Triangle. Iterate from 1 to numRows, generating each row using the generateRow function. Append each generated row to the ans vector. Complexity: Since generating each row takes ğ‘‚ ( row ) O(row) time and there are numRows rows, the overall time complexity is ğ‘‚ ( ğ‘› 2 ) O(n 2 ), where n is numRows. Complexity Analysis: Time Complexity: Generate Row: For each row i, generating the row takes ğ‘‚ ( ğ‘– ) O(i) time. Generate Triangle: Summing up the time for generating each row from 1 to numRows gives: ğ‘‚ ( 1 ) + ğ‘‚ ( 2 ) + ğ‘‚ ( 3 ) + â€¦ + ğ‘‚ ( ğ‘› ) = ğ‘‚ ( ğ‘› Ã— ( ğ‘› + 1 ) 2 ) = ğ‘‚ ( ğ‘› 2 ) O(1)+O(2)+O(3)+â€¦+O(n)=O( 2 nÃ—(n+1) â€‹ )=O(n 2 ) Therefore, the overall time complexity is ğ‘‚ ( ğ‘› 2 ) O(n 2 ), where n is the number of rows. Space Complexity: Row Storage: Storing a single row requires ğ‘‚ ( ğ‘Ÿ ğ‘œ ğ‘¤ ) O(row) space. Triangle Storage: Storing the entire Pascal's Triangle up to numRows requires space for all rows. The space complexity for storing the result is: ğ‘‚ ( 1 ) + ğ‘‚ ( 2 ) + ğ‘‚ ( 3 ) + â€¦ + ğ‘‚ ( ğ‘› ) = ğ‘‚ ( ğ‘› Ã— ( ğ‘› + 1 ) 2 ) = ğ‘‚ ( ğ‘› 2 ) O(1)+O(2)+O(3)+â€¦+O(n)=O( 2 nÃ—(n+1) â€‹ )=O(n 2 ) Therefore, the overall space complexity is ğ‘‚ ( ğ‘› 2 ) O(n 2 ), where n is the number of rows. This approach efficiently generates Pascal's Triangle up to the specified number of rows and provides a clear and simple method to understand the computation and storage of the triangle.

Program:
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        for(int row=1;row<=numRows;row++){
            ans.push_back(maker(row));
        }
        return ans;
    }
    vector<int>maker(int n){
        long long sum=1;
        vector<int> ans;
        ans.push_back(1);
        for(int i=1;i<n;i++){
            sum=sum * (n-i);
            sum=sum/i;
            ans.push_back(sum);
        }
        return ans;
    }
};
